{"ast":null,"code":"'use strict';\n\nconst FieldFlags = require('../constants/field_flags.js');\nconst Charsets = require('../constants/charsets.js');\nconst Types = require('../constants/types.js');\nconst helpers = require('../helpers');\nconst typeNames = [];\nfor (const t in Types) {\n  typeNames[Types[t]] = t;\n}\nfunction getBinaryParser(fields, _options, config) {\n  function readCode(field, config, options, fieldNum, packet) {\n    const supportBigNumbers = Boolean(options.supportBigNumbers || config.supportBigNumbers);\n    const bigNumberStrings = Boolean(options.bigNumberStrings || config.bigNumberStrings);\n    const timezone = options.timezone || config.timezone;\n    const dateStrings = options.dateStrings || config.dateStrings;\n    const unsigned = field.flags & FieldFlags.UNSIGNED;\n    switch (field.columnType) {\n      case Types.TINY:\n        return unsigned ? packet.readInt8() : packet.readSInt8();\n      case Types.SHORT:\n        return unsigned ? packet.readInt16() : packet.readSInt16();\n      case Types.LONG:\n      case Types.INT24:\n        // in binary protocol int24 is encoded in 4 bytes int32\n        return unsigned ? packet.readInt32() : packet.readSInt32();\n      case Types.YEAR:\n        return packet.readInt16();\n      case Types.FLOAT:\n        return packet.readFloat();\n      case Types.DOUBLE:\n        return packet.readDouble();\n      case Types.NULL:\n        return null;\n      case Types.DATE:\n      case Types.DATETIME:\n      case Types.TIMESTAMP:\n      case Types.NEWDATE:\n        return helpers.typeMatch(field.columnType, dateStrings, Types) ? packet.readDateTimeString(parseInt(field.decimals, 10), null, field.columnType) : packet.readDateTime(timezone);\n      case Types.TIME:\n        return packet.readTimeString();\n      case Types.DECIMAL:\n      case Types.NEWDECIMAL:\n        return config.decimalNumbers ? packet.parseLengthCodedFloat() : packet.readLengthCodedString('ascii');\n      case Types.GEOMETRY:\n        return packet.parseGeometryValue();\n      case Types.VECTOR:\n        return packet.parseVector();\n      case Types.JSON:\n        // Since for JSON columns mysql always returns charset 63 (BINARY),\n        // we have to handle it according to JSON specs and use \"utf8\",\n        // see https://github.com/sidorares/node-mysql2/issues/409\n        return config.jsonStrings ? packet.readLengthCodedString('utf8') : JSON.parse(packet.readLengthCodedString('utf8'));\n      case Types.LONGLONG:\n        if (!supportBigNumbers) return unsigned ? packet.readInt64JSNumber() : packet.readSInt64JSNumber();\n        return bigNumberStrings ? unsigned ? packet.readInt64String() : packet.readSInt64String() : unsigned ? packet.readInt64() : packet.readSInt64();\n      default:\n        return field.characterSet === Charsets.BINARY ? packet.readLengthCodedBuffer() : packet.readLengthCodedString(fields[fieldNum].encoding);\n    }\n  }\n  return class BinaryRow {\n    constructor() {}\n    next(packet, fields, options) {\n      packet.readInt8(); // status byte\n\n      const nullBitmapLength = Math.floor((fields.length + 7 + 2) / 8);\n      const nullBitmaskBytes = new Array(nullBitmapLength);\n      for (let i = 0; i < nullBitmapLength; i++) {\n        nullBitmaskBytes[i] = packet.readInt8();\n      }\n      const result = options.rowsAsArray ? new Array(fields.length) : {};\n      let currentFieldNullBit = 4;\n      let nullByteIndex = 0;\n      for (let i = 0; i < fields.length; i++) {\n        const field = fields[i];\n        const typeCast = options.typeCast !== undefined ? options.typeCast : config.typeCast;\n        let value;\n        if (nullBitmaskBytes[nullByteIndex] & currentFieldNullBit) {\n          value = null;\n        } else if (options.typeCast === false) {\n          value = packet.readLengthCodedBuffer();\n        } else {\n          const next = () => readCode(field, config, options, i, packet);\n          value = typeof typeCast === 'function' ? typeCast({\n            type: typeNames[field.columnType],\n            length: field.columnLength,\n            db: field.schema,\n            table: field.table,\n            name: field.name,\n            string: function (encoding = field.encoding) {\n              if (field.columnType === Types.JSON && encoding === field.encoding) {\n                // Since for JSON columns mysql always returns charset 63 (BINARY),\n                // we have to handle it according to JSON specs and use \"utf8\",\n                // see https://github.com/sidorares/node-mysql2/issues/1661\n                console.warn(`typeCast: JSON column \"${field.name}\" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \\`field.string(\"utf8\")\\``);\n              }\n              if ([Types.DATETIME, Types.NEWDATE, Types.TIMESTAMP, Types.DATE].includes(field.columnType)) {\n                return packet.readDateTimeString(parseInt(field.decimals, 10));\n              }\n              if (field.columnType === Types.TINY) {\n                const unsigned = field.flags & FieldFlags.UNSIGNED;\n                return String(unsigned ? packet.readInt8() : packet.readSInt8());\n              }\n              if (field.columnType === Types.TIME) {\n                return packet.readTimeString();\n              }\n              return packet.readLengthCodedString(encoding);\n            },\n            buffer: function () {\n              return packet.readLengthCodedBuffer();\n            },\n            geometry: function () {\n              return packet.parseGeometryValue();\n            }\n          }, next) : next();\n        }\n        if (options.rowsAsArray) {\n          result[i] = value;\n        } else if (typeof options.nestTables === 'string') {\n          const key = helpers.fieldEscape(field.table + options.nestTables + field.name, false);\n          result[key] = value;\n        } else if (options.nestTables === true) {\n          const tableName = helpers.fieldEscape(field.table, false);\n          if (!result[tableName]) {\n            result[tableName] = {};\n          }\n          const fieldName = helpers.fieldEscape(field.name, false);\n          result[tableName][fieldName] = value;\n        } else {\n          const key = helpers.fieldEscape(field.name, false);\n          result[key] = value;\n        }\n        currentFieldNullBit *= 2;\n        if (currentFieldNullBit === 0x100) {\n          currentFieldNullBit = 1;\n          nullByteIndex++;\n        }\n      }\n      return result;\n    }\n  };\n}\nmodule.exports = getBinaryParser;","map":{"version":3,"names":["FieldFlags","require","Charsets","Types","helpers","typeNames","t","getBinaryParser","fields","_options","config","readCode","field","options","fieldNum","packet","supportBigNumbers","Boolean","bigNumberStrings","timezone","dateStrings","unsigned","flags","UNSIGNED","columnType","TINY","readInt8","readSInt8","SHORT","readInt16","readSInt16","LONG","INT24","readInt32","readSInt32","YEAR","FLOAT","readFloat","DOUBLE","readDouble","NULL","DATE","DATETIME","TIMESTAMP","NEWDATE","typeMatch","readDateTimeString","parseInt","decimals","readDateTime","TIME","readTimeString","DECIMAL","NEWDECIMAL","decimalNumbers","parseLengthCodedFloat","readLengthCodedString","GEOMETRY","parseGeometryValue","VECTOR","parseVector","JSON","jsonStrings","parse","LONGLONG","readInt64JSNumber","readSInt64JSNumber","readInt64String","readSInt64String","readInt64","readSInt64","characterSet","BINARY","readLengthCodedBuffer","encoding","BinaryRow","constructor","next","nullBitmapLength","Math","floor","length","nullBitmaskBytes","Array","i","result","rowsAsArray","currentFieldNullBit","nullByteIndex","typeCast","undefined","value","type","columnLength","db","schema","table","name","string","console","warn","includes","String","buffer","geometry","nestTables","key","fieldEscape","tableName","fieldName","module","exports"],"sources":["D:/Customer Query Assistant/Customer Query Assistant/client/node_modules/mysql2/lib/parsers/static_binary_parser.js"],"sourcesContent":["'use strict';\n\nconst FieldFlags = require('../constants/field_flags.js');\nconst Charsets = require('../constants/charsets.js');\nconst Types = require('../constants/types.js');\nconst helpers = require('../helpers');\n\nconst typeNames = [];\nfor (const t in Types) {\n  typeNames[Types[t]] = t;\n}\n\nfunction getBinaryParser(fields, _options, config) {\n  function readCode(field, config, options, fieldNum, packet) {\n    const supportBigNumbers = Boolean(\n      options.supportBigNumbers || config.supportBigNumbers\n    );\n    const bigNumberStrings = Boolean(\n      options.bigNumberStrings || config.bigNumberStrings\n    );\n    const timezone = options.timezone || config.timezone;\n    const dateStrings = options.dateStrings || config.dateStrings;\n    const unsigned = field.flags & FieldFlags.UNSIGNED;\n\n    switch (field.columnType) {\n      case Types.TINY:\n        return unsigned ? packet.readInt8() : packet.readSInt8();\n      case Types.SHORT:\n        return unsigned ? packet.readInt16() : packet.readSInt16();\n      case Types.LONG:\n      case Types.INT24: // in binary protocol int24 is encoded in 4 bytes int32\n        return unsigned ? packet.readInt32() : packet.readSInt32();\n      case Types.YEAR:\n        return packet.readInt16();\n      case Types.FLOAT:\n        return packet.readFloat();\n      case Types.DOUBLE:\n        return packet.readDouble();\n      case Types.NULL:\n        return null;\n      case Types.DATE:\n      case Types.DATETIME:\n      case Types.TIMESTAMP:\n      case Types.NEWDATE:\n        return helpers.typeMatch(field.columnType, dateStrings, Types)\n          ? packet.readDateTimeString(\n              parseInt(field.decimals, 10),\n              null,\n              field.columnType\n            )\n          : packet.readDateTime(timezone);\n      case Types.TIME:\n        return packet.readTimeString();\n      case Types.DECIMAL:\n      case Types.NEWDECIMAL:\n        return config.decimalNumbers\n          ? packet.parseLengthCodedFloat()\n          : packet.readLengthCodedString('ascii');\n      case Types.GEOMETRY:\n        return packet.parseGeometryValue();\n      case Types.VECTOR:\n        return packet.parseVector();\n      case Types.JSON:\n        // Since for JSON columns mysql always returns charset 63 (BINARY),\n        // we have to handle it according to JSON specs and use \"utf8\",\n        // see https://github.com/sidorares/node-mysql2/issues/409\n        return config.jsonStrings\n          ? packet.readLengthCodedString('utf8')\n          : JSON.parse(packet.readLengthCodedString('utf8'));\n      case Types.LONGLONG:\n        if (!supportBigNumbers)\n          return unsigned\n            ? packet.readInt64JSNumber()\n            : packet.readSInt64JSNumber();\n        return bigNumberStrings\n          ? unsigned\n            ? packet.readInt64String()\n            : packet.readSInt64String()\n          : unsigned\n            ? packet.readInt64()\n            : packet.readSInt64();\n      default:\n        return field.characterSet === Charsets.BINARY\n          ? packet.readLengthCodedBuffer()\n          : packet.readLengthCodedString(fields[fieldNum].encoding);\n    }\n  }\n\n  return class BinaryRow {\n    constructor() {}\n\n    next(packet, fields, options) {\n      packet.readInt8(); // status byte\n\n      const nullBitmapLength = Math.floor((fields.length + 7 + 2) / 8);\n      const nullBitmaskBytes = new Array(nullBitmapLength);\n\n      for (let i = 0; i < nullBitmapLength; i++) {\n        nullBitmaskBytes[i] = packet.readInt8();\n      }\n\n      const result = options.rowsAsArray ? new Array(fields.length) : {};\n      let currentFieldNullBit = 4;\n      let nullByteIndex = 0;\n\n      for (let i = 0; i < fields.length; i++) {\n        const field = fields[i];\n        const typeCast =\n          options.typeCast !== undefined ? options.typeCast : config.typeCast;\n\n        let value;\n        if (nullBitmaskBytes[nullByteIndex] & currentFieldNullBit) {\n          value = null;\n        } else if (options.typeCast === false) {\n          value = packet.readLengthCodedBuffer();\n        } else {\n          const next = () => readCode(field, config, options, i, packet);\n          value =\n            typeof typeCast === 'function'\n              ? typeCast(\n                  {\n                    type: typeNames[field.columnType],\n                    length: field.columnLength,\n                    db: field.schema,\n                    table: field.table,\n                    name: field.name,\n                    string: function (encoding = field.encoding) {\n                      if (\n                        field.columnType === Types.JSON &&\n                        encoding === field.encoding\n                      ) {\n                        // Since for JSON columns mysql always returns charset 63 (BINARY),\n                        // we have to handle it according to JSON specs and use \"utf8\",\n                        // see https://github.com/sidorares/node-mysql2/issues/1661\n                        console.warn(\n                          `typeCast: JSON column \"${field.name}\" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \\`field.string(\"utf8\")\\``\n                        );\n                      }\n\n                      if (\n                        [\n                          Types.DATETIME,\n                          Types.NEWDATE,\n                          Types.TIMESTAMP,\n                          Types.DATE,\n                        ].includes(field.columnType)\n                      ) {\n                        return packet.readDateTimeString(\n                          parseInt(field.decimals, 10)\n                        );\n                      }\n\n                      if (field.columnType === Types.TINY) {\n                        const unsigned = field.flags & FieldFlags.UNSIGNED;\n\n                        return String(\n                          unsigned ? packet.readInt8() : packet.readSInt8()\n                        );\n                      }\n\n                      if (field.columnType === Types.TIME) {\n                        return packet.readTimeString();\n                      }\n\n                      return packet.readLengthCodedString(encoding);\n                    },\n                    buffer: function () {\n                      return packet.readLengthCodedBuffer();\n                    },\n                    geometry: function () {\n                      return packet.parseGeometryValue();\n                    },\n                  },\n                  next\n                )\n              : next();\n        }\n\n        if (options.rowsAsArray) {\n          result[i] = value;\n        } else if (typeof options.nestTables === 'string') {\n          const key = helpers.fieldEscape(\n            field.table + options.nestTables + field.name,\n            false\n          );\n          result[key] = value;\n        } else if (options.nestTables === true) {\n          const tableName = helpers.fieldEscape(field.table, false);\n          if (!result[tableName]) {\n            result[tableName] = {};\n          }\n          const fieldName = helpers.fieldEscape(field.name, false);\n          result[tableName][fieldName] = value;\n        } else {\n          const key = helpers.fieldEscape(field.name, false);\n          result[key] = value;\n        }\n\n        currentFieldNullBit *= 2;\n        if (currentFieldNullBit === 0x100) {\n          currentFieldNullBit = 1;\n          nullByteIndex++;\n        }\n      }\n\n      return result;\n    }\n  };\n}\n\nmodule.exports = getBinaryParser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}