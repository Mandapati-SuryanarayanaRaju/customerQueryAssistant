{"ast":null,"code":"'use strict';\n\nconst process = require('process');\nconst Pool = require('./pool.js');\nconst PoolConfig = require('./pool_config.js');\nconst Connection = require('./connection.js');\nconst EventEmitter = require('events').EventEmitter;\n\n/**\n * Selector\n */\nconst makeSelector = {\n  RR() {\n    let index = 0;\n    return clusterIds => clusterIds[index++ % clusterIds.length];\n  },\n  RANDOM() {\n    return clusterIds => clusterIds[Math.floor(Math.random() * clusterIds.length)];\n  },\n  ORDER() {\n    return clusterIds => clusterIds[0];\n  }\n};\nconst getMonotonicMilliseconds = function () {\n  let ms;\n  if (typeof process.hrtime === 'function') {\n    ms = process.hrtime();\n    ms = ms[0] * 1e3 + ms[1] * 1e-6;\n  } else {\n    ms = process.uptime() * 1000;\n  }\n  return Math.floor(ms);\n};\nconst patternRegExp = function (pattern) {\n  if (pattern instanceof RegExp) {\n    return pattern;\n  }\n  const source = pattern.replace(/([.+?^=!:${}()|[\\]/\\\\])/g, '\\\\$1').replace(/\\*/g, '.*');\n  return new RegExp(`^${source}$`);\n};\nclass PoolNamespace {\n  constructor(cluster, pattern, selector) {\n    this._cluster = cluster;\n    this._pattern = pattern;\n    this._selector = makeSelector[selector]();\n  }\n  getConnection(cb) {\n    const clusterNode = this._getClusterNode();\n    if (clusterNode === null) {\n      let err = new Error('Pool does Not exist.');\n      err.code = 'POOL_NOEXIST';\n      if (this._cluster._findNodeIds(this._pattern, true).length !== 0) {\n        err = new Error('Pool does Not have online node.');\n        err.code = 'POOL_NONEONLINE';\n      }\n      return cb(err);\n    }\n    return this._cluster._getConnection(clusterNode, (err, connection) => {\n      if (err) {\n        if (this._cluster._canRetry && this._cluster._findNodeIds(this._pattern).length !== 0) {\n          this._cluster.emit('warn', err);\n          return this.getConnection(cb);\n        }\n        return cb(err);\n      }\n      return cb(null, connection);\n    });\n  }\n\n  /**\n   * pool cluster query\n   * @param {*} sql\n   * @param {*} values\n   * @param {*} cb\n   * @returns query\n   */\n  query(sql, values, cb) {\n    const query = Connection.createQuery(sql, values, cb, {});\n    this.getConnection((err, conn) => {\n      if (err) {\n        if (typeof query.onResult === 'function') {\n          query.onResult(err);\n        } else {\n          query.emit('error', err);\n        }\n        return;\n      }\n      try {\n        conn.query(query).once('end', () => {\n          conn.release();\n        });\n      } catch (e) {\n        conn.release();\n        throw e;\n      }\n    });\n    return query;\n  }\n\n  /**\n   * pool cluster execute\n   * @param {*} sql\n   * @param {*} values\n   * @param {*} cb\n   */\n  execute(sql, values, cb) {\n    if (typeof values === 'function') {\n      cb = values;\n      values = [];\n    }\n    this.getConnection((err, conn) => {\n      if (err) {\n        return cb(err);\n      }\n      try {\n        conn.execute(sql, values, cb).once('end', () => {\n          conn.release();\n        });\n      } catch (e) {\n        conn.release();\n        throw e;\n      }\n    });\n  }\n  _getClusterNode() {\n    const foundNodeIds = this._cluster._findNodeIds(this._pattern);\n    if (foundNodeIds.length === 0) {\n      return null;\n    }\n    const nodeId = foundNodeIds.length === 1 ? foundNodeIds[0] : this._selector(foundNodeIds);\n    return this._cluster._getNode(nodeId);\n  }\n}\nclass PoolCluster extends EventEmitter {\n  constructor(config) {\n    super();\n    config = config || {};\n    this._canRetry = typeof config.canRetry === 'undefined' ? true : config.canRetry;\n    this._removeNodeErrorCount = config.removeNodeErrorCount || 5;\n    this._restoreNodeTimeout = config.restoreNodeTimeout || 0;\n    this._defaultSelector = config.defaultSelector || 'RR';\n    this._closed = false;\n    this._lastId = 0;\n    this._nodes = {};\n    this._serviceableNodeIds = [];\n    this._namespaces = {};\n    this._findCaches = {};\n  }\n  of(pattern, selector) {\n    pattern = pattern || '*';\n    selector = selector || this._defaultSelector;\n    selector = selector.toUpperCase();\n    if (!makeSelector[selector] === 'undefined') {\n      selector = this._defaultSelector;\n    }\n    const key = pattern + selector;\n    if (typeof this._namespaces[key] === 'undefined') {\n      this._namespaces[key] = new PoolNamespace(this, pattern, selector);\n    }\n    return this._namespaces[key];\n  }\n  add(id, config) {\n    if (typeof id === 'object') {\n      config = id;\n      id = `CLUSTER::${++this._lastId}`;\n    }\n    if (typeof this._nodes[id] === 'undefined') {\n      this._nodes[id] = {\n        id: id,\n        errorCount: 0,\n        pool: new Pool({\n          config: new PoolConfig(config)\n        }),\n        _offlineUntil: 0\n      };\n      this._serviceableNodeIds.push(id);\n      this._clearFindCaches();\n    }\n  }\n  remove(pattern) {\n    const foundNodeIds = this._findNodeIds(pattern, true);\n    for (let i = 0; i < foundNodeIds.length; i++) {\n      const node = this._getNode(foundNodeIds[i]);\n      if (node) {\n        this._removeNode(node);\n      }\n    }\n  }\n  getConnection(pattern, selector, cb) {\n    let namespace;\n    if (typeof pattern === 'function') {\n      cb = pattern;\n      namespace = this.of();\n    } else {\n      if (typeof selector === 'function') {\n        cb = selector;\n        selector = this._defaultSelector;\n      }\n      namespace = this.of(pattern, selector);\n    }\n    namespace.getConnection(cb);\n  }\n  end(callback) {\n    const cb = callback !== undefined ? callback : err => {\n      if (err) {\n        throw err;\n      }\n    };\n    if (this._closed) {\n      process.nextTick(cb);\n      return;\n    }\n    this._closed = true;\n    let calledBack = false;\n    let waitingClose = 0;\n    const onEnd = err => {\n      if (!calledBack && (err || --waitingClose <= 0)) {\n        calledBack = true;\n        return cb(err);\n      }\n    };\n    for (const id in this._nodes) {\n      waitingClose++;\n      this._nodes[id].pool.end(onEnd);\n    }\n    if (waitingClose === 0) {\n      process.nextTick(onEnd);\n    }\n  }\n  _findNodeIds(pattern, includeOffline) {\n    let currentTime = 0;\n    let foundNodeIds = this._findCaches[pattern];\n    if (foundNodeIds === undefined) {\n      const expression = patternRegExp(pattern);\n      foundNodeIds = this._serviceableNodeIds.filter(id => id.match(expression));\n    }\n    this._findCaches[pattern] = foundNodeIds;\n    if (includeOffline) {\n      return foundNodeIds;\n    }\n    return foundNodeIds.filter(nodeId => {\n      const node = this._getNode(nodeId);\n      if (!node._offlineUntil) {\n        return true;\n      }\n      if (!currentTime) {\n        currentTime = getMonotonicMilliseconds();\n      }\n      return node._offlineUntil <= currentTime;\n    });\n  }\n  _getNode(id) {\n    return this._nodes[id] || null;\n  }\n  _increaseErrorCount(node) {\n    const errorCount = ++node.errorCount;\n    if (this._removeNodeErrorCount > errorCount) {\n      return;\n    }\n    if (this._restoreNodeTimeout > 0) {\n      node._offlineUntil = getMonotonicMilliseconds() + this._restoreNodeTimeout;\n      this.emit('offline', node.id);\n      return;\n    }\n    this._removeNode(node);\n    this.emit('remove', node.id);\n  }\n  _decreaseErrorCount(node) {\n    let errorCount = node.errorCount;\n    if (errorCount > this._removeNodeErrorCount) {\n      errorCount = this._removeNodeErrorCount;\n    }\n    if (errorCount < 1) {\n      errorCount = 1;\n    }\n    node.errorCount = errorCount - 1;\n    if (node._offlineUntil) {\n      node._offlineUntil = 0;\n      this.emit('online', node.id);\n    }\n  }\n  _getConnection(node, cb) {\n    node.pool.getConnection((err, connection) => {\n      if (err) {\n        this._increaseErrorCount(node);\n        return cb(err);\n      }\n      this._decreaseErrorCount(node);\n      connection._clusterId = node.id;\n      return cb(null, connection);\n    });\n  }\n  _removeNode(node) {\n    const index = this._serviceableNodeIds.indexOf(node.id);\n    if (index !== -1) {\n      this._serviceableNodeIds.splice(index, 1);\n      delete this._nodes[node.id];\n      this._clearFindCaches();\n      node.pool.end();\n    }\n  }\n  _clearFindCaches() {\n    this._findCaches = {};\n  }\n}\nmodule.exports = PoolCluster;","map":{"version":3,"names":["process","require","Pool","PoolConfig","Connection","EventEmitter","makeSelector","RR","index","clusterIds","length","RANDOM","Math","floor","random","ORDER","getMonotonicMilliseconds","ms","hrtime","uptime","patternRegExp","pattern","RegExp","source","replace","PoolNamespace","constructor","cluster","selector","_cluster","_pattern","_selector","getConnection","cb","clusterNode","_getClusterNode","err","Error","code","_findNodeIds","_getConnection","connection","_canRetry","emit","query","sql","values","createQuery","conn","onResult","once","release","e","execute","foundNodeIds","nodeId","_getNode","PoolCluster","config","canRetry","_removeNodeErrorCount","removeNodeErrorCount","_restoreNodeTimeout","restoreNodeTimeout","_defaultSelector","defaultSelector","_closed","_lastId","_nodes","_serviceableNodeIds","_namespaces","_findCaches","of","toUpperCase","key","add","id","errorCount","pool","_offlineUntil","push","_clearFindCaches","remove","i","node","_removeNode","namespace","end","callback","undefined","nextTick","calledBack","waitingClose","onEnd","includeOffline","currentTime","expression","filter","match","_increaseErrorCount","_decreaseErrorCount","_clusterId","indexOf","splice","module","exports"],"sources":["D:/Customer Query Assistant/Customer Query Assistant/client/node_modules/mysql2/lib/pool_cluster.js"],"sourcesContent":["'use strict';\n\nconst process = require('process');\n\nconst Pool = require('./pool.js');\nconst PoolConfig = require('./pool_config.js');\nconst Connection = require('./connection.js');\nconst EventEmitter = require('events').EventEmitter;\n\n/**\n * Selector\n */\nconst makeSelector = {\n  RR() {\n    let index = 0;\n    return (clusterIds) => clusterIds[index++ % clusterIds.length];\n  },\n  RANDOM() {\n    return (clusterIds) =>\n      clusterIds[Math.floor(Math.random() * clusterIds.length)];\n  },\n  ORDER() {\n    return (clusterIds) => clusterIds[0];\n  },\n};\n\nconst getMonotonicMilliseconds = function () {\n  let ms;\n\n  if (typeof process.hrtime === 'function') {\n    ms = process.hrtime();\n    ms = ms[0] * 1e3 + ms[1] * 1e-6;\n  } else {\n    ms = process.uptime() * 1000;\n  }\n\n  return Math.floor(ms);\n};\n\nconst patternRegExp = function (pattern) {\n  if (pattern instanceof RegExp) {\n    return pattern;\n  }\n\n  const source = pattern\n    .replace(/([.+?^=!:${}()|[\\]/\\\\])/g, '\\\\$1')\n    .replace(/\\*/g, '.*');\n\n  return new RegExp(`^${source}$`);\n};\n\nclass PoolNamespace {\n  constructor(cluster, pattern, selector) {\n    this._cluster = cluster;\n    this._pattern = pattern;\n    this._selector = makeSelector[selector]();\n  }\n\n  getConnection(cb) {\n    const clusterNode = this._getClusterNode();\n    if (clusterNode === null) {\n      let err = new Error('Pool does Not exist.');\n      err.code = 'POOL_NOEXIST';\n\n      if (this._cluster._findNodeIds(this._pattern, true).length !== 0) {\n        err = new Error('Pool does Not have online node.');\n        err.code = 'POOL_NONEONLINE';\n      }\n\n      return cb(err);\n    }\n    return this._cluster._getConnection(clusterNode, (err, connection) => {\n      if (err) {\n        if (\n          this._cluster._canRetry &&\n          this._cluster._findNodeIds(this._pattern).length !== 0\n        ) {\n          this._cluster.emit('warn', err);\n          return this.getConnection(cb);\n        }\n\n        return cb(err);\n      }\n      return cb(null, connection);\n    });\n  }\n\n  /**\n   * pool cluster query\n   * @param {*} sql\n   * @param {*} values\n   * @param {*} cb\n   * @returns query\n   */\n  query(sql, values, cb) {\n    const query = Connection.createQuery(sql, values, cb, {});\n    this.getConnection((err, conn) => {\n      if (err) {\n        if (typeof query.onResult === 'function') {\n          query.onResult(err);\n        } else {\n          query.emit('error', err);\n        }\n        return;\n      }\n      try {\n        conn.query(query).once('end', () => {\n          conn.release();\n        });\n      } catch (e) {\n        conn.release();\n        throw e;\n      }\n    });\n    return query;\n  }\n\n  /**\n   * pool cluster execute\n   * @param {*} sql\n   * @param {*} values\n   * @param {*} cb\n   */\n  execute(sql, values, cb) {\n    if (typeof values === 'function') {\n      cb = values;\n      values = [];\n    }\n    this.getConnection((err, conn) => {\n      if (err) {\n        return cb(err);\n      }\n      try {\n        conn.execute(sql, values, cb).once('end', () => {\n          conn.release();\n        });\n      } catch (e) {\n        conn.release();\n        throw e;\n      }\n    });\n  }\n\n  _getClusterNode() {\n    const foundNodeIds = this._cluster._findNodeIds(this._pattern);\n    if (foundNodeIds.length === 0) {\n      return null;\n    }\n    const nodeId =\n      foundNodeIds.length === 1\n        ? foundNodeIds[0]\n        : this._selector(foundNodeIds);\n    return this._cluster._getNode(nodeId);\n  }\n}\n\nclass PoolCluster extends EventEmitter {\n  constructor(config) {\n    super();\n    config = config || {};\n    this._canRetry =\n      typeof config.canRetry === 'undefined' ? true : config.canRetry;\n    this._removeNodeErrorCount = config.removeNodeErrorCount || 5;\n    this._restoreNodeTimeout = config.restoreNodeTimeout || 0;\n    this._defaultSelector = config.defaultSelector || 'RR';\n    this._closed = false;\n    this._lastId = 0;\n    this._nodes = {};\n    this._serviceableNodeIds = [];\n    this._namespaces = {};\n    this._findCaches = {};\n  }\n\n  of(pattern, selector) {\n    pattern = pattern || '*';\n    selector = selector || this._defaultSelector;\n    selector = selector.toUpperCase();\n    if (!makeSelector[selector] === 'undefined') {\n      selector = this._defaultSelector;\n    }\n    const key = pattern + selector;\n    if (typeof this._namespaces[key] === 'undefined') {\n      this._namespaces[key] = new PoolNamespace(this, pattern, selector);\n    }\n    return this._namespaces[key];\n  }\n\n  add(id, config) {\n    if (typeof id === 'object') {\n      config = id;\n      id = `CLUSTER::${++this._lastId}`;\n    }\n    if (typeof this._nodes[id] === 'undefined') {\n      this._nodes[id] = {\n        id: id,\n        errorCount: 0,\n        pool: new Pool({ config: new PoolConfig(config) }),\n        _offlineUntil: 0,\n      };\n      this._serviceableNodeIds.push(id);\n      this._clearFindCaches();\n    }\n  }\n\n  remove(pattern) {\n    const foundNodeIds = this._findNodeIds(pattern, true);\n\n    for (let i = 0; i < foundNodeIds.length; i++) {\n      const node = this._getNode(foundNodeIds[i]);\n\n      if (node) {\n        this._removeNode(node);\n      }\n    }\n  }\n\n  getConnection(pattern, selector, cb) {\n    let namespace;\n    if (typeof pattern === 'function') {\n      cb = pattern;\n      namespace = this.of();\n    } else {\n      if (typeof selector === 'function') {\n        cb = selector;\n        selector = this._defaultSelector;\n      }\n      namespace = this.of(pattern, selector);\n    }\n    namespace.getConnection(cb);\n  }\n\n  end(callback) {\n    const cb =\n      callback !== undefined\n        ? callback\n        : (err) => {\n            if (err) {\n              throw err;\n            }\n          };\n    if (this._closed) {\n      process.nextTick(cb);\n      return;\n    }\n\n    this._closed = true;\n\n    let calledBack = false;\n    let waitingClose = 0;\n    const onEnd = (err) => {\n      if (!calledBack && (err || --waitingClose <= 0)) {\n        calledBack = true;\n        return cb(err);\n      }\n    };\n\n    for (const id in this._nodes) {\n      waitingClose++;\n      this._nodes[id].pool.end(onEnd);\n    }\n\n    if (waitingClose === 0) {\n      process.nextTick(onEnd);\n    }\n  }\n\n  _findNodeIds(pattern, includeOffline) {\n    let currentTime = 0;\n    let foundNodeIds = this._findCaches[pattern];\n\n    if (foundNodeIds === undefined) {\n      const expression = patternRegExp(pattern);\n\n      foundNodeIds = this._serviceableNodeIds.filter((id) =>\n        id.match(expression)\n      );\n    }\n\n    this._findCaches[pattern] = foundNodeIds;\n\n    if (includeOffline) {\n      return foundNodeIds;\n    }\n\n    return foundNodeIds.filter((nodeId) => {\n      const node = this._getNode(nodeId);\n\n      if (!node._offlineUntil) {\n        return true;\n      }\n\n      if (!currentTime) {\n        currentTime = getMonotonicMilliseconds();\n      }\n\n      return node._offlineUntil <= currentTime;\n    });\n  }\n\n  _getNode(id) {\n    return this._nodes[id] || null;\n  }\n\n  _increaseErrorCount(node) {\n    const errorCount = ++node.errorCount;\n\n    if (this._removeNodeErrorCount > errorCount) {\n      return;\n    }\n\n    if (this._restoreNodeTimeout > 0) {\n      node._offlineUntil =\n        getMonotonicMilliseconds() + this._restoreNodeTimeout;\n      this.emit('offline', node.id);\n      return;\n    }\n\n    this._removeNode(node);\n    this.emit('remove', node.id);\n  }\n\n  _decreaseErrorCount(node) {\n    let errorCount = node.errorCount;\n\n    if (errorCount > this._removeNodeErrorCount) {\n      errorCount = this._removeNodeErrorCount;\n    }\n\n    if (errorCount < 1) {\n      errorCount = 1;\n    }\n\n    node.errorCount = errorCount - 1;\n\n    if (node._offlineUntil) {\n      node._offlineUntil = 0;\n      this.emit('online', node.id);\n    }\n  }\n\n  _getConnection(node, cb) {\n    node.pool.getConnection((err, connection) => {\n      if (err) {\n        this._increaseErrorCount(node);\n        return cb(err);\n      }\n      this._decreaseErrorCount(node);\n\n      connection._clusterId = node.id;\n      return cb(null, connection);\n    });\n  }\n\n  _removeNode(node) {\n    const index = this._serviceableNodeIds.indexOf(node.id);\n    if (index !== -1) {\n      this._serviceableNodeIds.splice(index, 1);\n      delete this._nodes[node.id];\n      this._clearFindCaches();\n      node.pool.end();\n    }\n  }\n\n  _clearFindCaches() {\n    this._findCaches = {};\n  }\n}\n\nmodule.exports = PoolCluster;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}