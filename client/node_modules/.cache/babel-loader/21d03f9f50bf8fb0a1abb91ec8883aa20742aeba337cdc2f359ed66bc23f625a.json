{"ast":null,"code":"'use strict';\n\nconst Types = require('../constants/types.js');\nconst Charsets = require('../constants/charsets.js');\nconst helpers = require('../helpers');\nconst typeNames = [];\nfor (const t in Types) {\n  typeNames[Types[t]] = t;\n}\nfunction readField({\n  packet,\n  type,\n  charset,\n  encoding,\n  config,\n  options\n}) {\n  const supportBigNumbers = Boolean(options.supportBigNumbers || config.supportBigNumbers);\n  const bigNumberStrings = Boolean(options.bigNumberStrings || config.bigNumberStrings);\n  const timezone = options.timezone || config.timezone;\n  const dateStrings = options.dateStrings || config.dateStrings;\n  switch (type) {\n    case Types.TINY:\n    case Types.SHORT:\n    case Types.LONG:\n    case Types.INT24:\n    case Types.YEAR:\n      return packet.parseLengthCodedIntNoBigCheck();\n    case Types.LONGLONG:\n      if (supportBigNumbers && bigNumberStrings) {\n        return packet.parseLengthCodedIntString();\n      }\n      return packet.parseLengthCodedInt(supportBigNumbers);\n    case Types.FLOAT:\n    case Types.DOUBLE:\n      return packet.parseLengthCodedFloat();\n    case Types.NULL:\n    case Types.DECIMAL:\n    case Types.NEWDECIMAL:\n      if (config.decimalNumbers) {\n        return packet.parseLengthCodedFloat();\n      }\n      return packet.readLengthCodedString('ascii');\n    case Types.DATE:\n      if (helpers.typeMatch(type, dateStrings, Types)) {\n        return packet.readLengthCodedString('ascii');\n      }\n      return packet.parseDate(timezone);\n    case Types.DATETIME:\n    case Types.TIMESTAMP:\n      if (helpers.typeMatch(type, dateStrings, Types)) {\n        return packet.readLengthCodedString('ascii');\n      }\n      return packet.parseDateTime(timezone);\n    case Types.TIME:\n      return packet.readLengthCodedString('ascii');\n    case Types.GEOMETRY:\n      return packet.parseGeometryValue();\n    case Types.VECTOR:\n      return packet.parseVector();\n    case Types.JSON:\n      // Since for JSON columns mysql always returns charset 63 (BINARY),\n      // we have to handle it according to JSON specs and use \"utf8\",\n      // see https://github.com/sidorares/node-mysql2/issues/409\n      return config.jsonStrings ? packet.readLengthCodedString('utf8') : JSON.parse(packet.readLengthCodedString('utf8'));\n    default:\n      if (charset === Charsets.BINARY) {\n        return packet.readLengthCodedBuffer();\n      }\n      return packet.readLengthCodedString(encoding);\n  }\n}\nfunction createTypecastField(field, packet) {\n  return {\n    type: typeNames[field.columnType],\n    length: field.columnLength,\n    db: field.schema,\n    table: field.table,\n    name: field.name,\n    string: function (encoding = field.encoding) {\n      if (field.columnType === Types.JSON && encoding === field.encoding) {\n        // Since for JSON columns mysql always returns charset 63 (BINARY),\n        // we have to handle it according to JSON specs and use \"utf8\",\n        // see https://github.com/sidorares/node-mysql2/issues/1661\n        console.warn(`typeCast: JSON column \"${field.name}\" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \\`field.string(\"utf8\")\\``);\n      }\n      return packet.readLengthCodedString(encoding);\n    },\n    buffer: function () {\n      return packet.readLengthCodedBuffer();\n    },\n    geometry: function () {\n      return packet.parseGeometryValue();\n    }\n  };\n}\nfunction getTextParser(_fields, _options, config) {\n  return {\n    next(packet, fields, options) {\n      const result = options.rowsAsArray ? [] : {};\n      for (let i = 0; i < fields.length; i++) {\n        const field = fields[i];\n        const typeCast = options.typeCast ? options.typeCast : config.typeCast;\n        const next = () => readField({\n          packet,\n          type: field.columnType,\n          encoding: field.encoding,\n          charset: field.characterSet,\n          config,\n          options\n        });\n        let value;\n        if (options.typeCast === false) {\n          value = packet.readLengthCodedBuffer();\n        } else if (typeof typeCast === 'function') {\n          value = typeCast(createTypecastField(field, packet), next);\n        } else {\n          value = next();\n        }\n        if (options.rowsAsArray) {\n          result.push(value);\n        } else if (typeof options.nestTables === 'string') {\n          result[`${helpers.fieldEscape(field.table, false)}${options.nestTables}${helpers.fieldEscape(field.name, false)}`] = value;\n        } else if (options.nestTables) {\n          const tableName = helpers.fieldEscape(field.table, false);\n          if (!result[tableName]) {\n            result[tableName] = {};\n          }\n          result[tableName][helpers.fieldEscape(field.name, false)] = value;\n        } else {\n          result[helpers.fieldEscape(field.name, false)] = value;\n        }\n      }\n      return result;\n    }\n  };\n}\nmodule.exports = getTextParser;","map":{"version":3,"names":["Types","require","Charsets","helpers","typeNames","t","readField","packet","type","charset","encoding","config","options","supportBigNumbers","Boolean","bigNumberStrings","timezone","dateStrings","TINY","SHORT","LONG","INT24","YEAR","parseLengthCodedIntNoBigCheck","LONGLONG","parseLengthCodedIntString","parseLengthCodedInt","FLOAT","DOUBLE","parseLengthCodedFloat","NULL","DECIMAL","NEWDECIMAL","decimalNumbers","readLengthCodedString","DATE","typeMatch","parseDate","DATETIME","TIMESTAMP","parseDateTime","TIME","GEOMETRY","parseGeometryValue","VECTOR","parseVector","JSON","jsonStrings","parse","BINARY","readLengthCodedBuffer","createTypecastField","field","columnType","length","columnLength","db","schema","table","name","string","console","warn","buffer","geometry","getTextParser","_fields","_options","next","fields","result","rowsAsArray","i","typeCast","characterSet","value","push","nestTables","fieldEscape","tableName","module","exports"],"sources":["D:/Customer Query Assistant/Customer Query Assistant/client/node_modules/mysql2/lib/parsers/static_text_parser.js"],"sourcesContent":["'use strict';\n\nconst Types = require('../constants/types.js');\nconst Charsets = require('../constants/charsets.js');\nconst helpers = require('../helpers');\n\nconst typeNames = [];\nfor (const t in Types) {\n  typeNames[Types[t]] = t;\n}\n\nfunction readField({ packet, type, charset, encoding, config, options }) {\n  const supportBigNumbers = Boolean(\n    options.supportBigNumbers || config.supportBigNumbers\n  );\n  const bigNumberStrings = Boolean(\n    options.bigNumberStrings || config.bigNumberStrings\n  );\n  const timezone = options.timezone || config.timezone;\n  const dateStrings = options.dateStrings || config.dateStrings;\n\n  switch (type) {\n    case Types.TINY:\n    case Types.SHORT:\n    case Types.LONG:\n    case Types.INT24:\n    case Types.YEAR:\n      return packet.parseLengthCodedIntNoBigCheck();\n    case Types.LONGLONG:\n      if (supportBigNumbers && bigNumberStrings) {\n        return packet.parseLengthCodedIntString();\n      }\n      return packet.parseLengthCodedInt(supportBigNumbers);\n    case Types.FLOAT:\n    case Types.DOUBLE:\n      return packet.parseLengthCodedFloat();\n    case Types.NULL:\n    case Types.DECIMAL:\n    case Types.NEWDECIMAL:\n      if (config.decimalNumbers) {\n        return packet.parseLengthCodedFloat();\n      }\n      return packet.readLengthCodedString('ascii');\n    case Types.DATE:\n      if (helpers.typeMatch(type, dateStrings, Types)) {\n        return packet.readLengthCodedString('ascii');\n      }\n      return packet.parseDate(timezone);\n    case Types.DATETIME:\n    case Types.TIMESTAMP:\n      if (helpers.typeMatch(type, dateStrings, Types)) {\n        return packet.readLengthCodedString('ascii');\n      }\n      return packet.parseDateTime(timezone);\n    case Types.TIME:\n      return packet.readLengthCodedString('ascii');\n    case Types.GEOMETRY:\n      return packet.parseGeometryValue();\n    case Types.VECTOR:\n      return packet.parseVector();\n    case Types.JSON:\n      // Since for JSON columns mysql always returns charset 63 (BINARY),\n      // we have to handle it according to JSON specs and use \"utf8\",\n      // see https://github.com/sidorares/node-mysql2/issues/409\n      return config.jsonStrings\n        ? packet.readLengthCodedString('utf8')\n        : JSON.parse(packet.readLengthCodedString('utf8'));\n    default:\n      if (charset === Charsets.BINARY) {\n        return packet.readLengthCodedBuffer();\n      }\n      return packet.readLengthCodedString(encoding);\n  }\n}\n\nfunction createTypecastField(field, packet) {\n  return {\n    type: typeNames[field.columnType],\n    length: field.columnLength,\n    db: field.schema,\n    table: field.table,\n    name: field.name,\n    string: function (encoding = field.encoding) {\n      if (field.columnType === Types.JSON && encoding === field.encoding) {\n        // Since for JSON columns mysql always returns charset 63 (BINARY),\n        // we have to handle it according to JSON specs and use \"utf8\",\n        // see https://github.com/sidorares/node-mysql2/issues/1661\n        console.warn(\n          `typeCast: JSON column \"${field.name}\" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \\`field.string(\"utf8\")\\``\n        );\n      }\n      return packet.readLengthCodedString(encoding);\n    },\n    buffer: function () {\n      return packet.readLengthCodedBuffer();\n    },\n    geometry: function () {\n      return packet.parseGeometryValue();\n    },\n  };\n}\n\nfunction getTextParser(_fields, _options, config) {\n  return {\n    next(packet, fields, options) {\n      const result = options.rowsAsArray ? [] : {};\n      for (let i = 0; i < fields.length; i++) {\n        const field = fields[i];\n        const typeCast = options.typeCast ? options.typeCast : config.typeCast;\n        const next = () =>\n          readField({\n            packet,\n            type: field.columnType,\n            encoding: field.encoding,\n            charset: field.characterSet,\n            config,\n            options,\n          });\n\n        let value;\n\n        if (options.typeCast === false) {\n          value = packet.readLengthCodedBuffer();\n        } else if (typeof typeCast === 'function') {\n          value = typeCast(createTypecastField(field, packet), next);\n        } else {\n          value = next();\n        }\n\n        if (options.rowsAsArray) {\n          result.push(value);\n        } else if (typeof options.nestTables === 'string') {\n          result[\n            `${helpers.fieldEscape(field.table, false)}${options.nestTables}${helpers.fieldEscape(field.name, false)}`\n          ] = value;\n        } else if (options.nestTables) {\n          const tableName = helpers.fieldEscape(field.table, false);\n          if (!result[tableName]) {\n            result[tableName] = {};\n          }\n          result[tableName][helpers.fieldEscape(field.name, false)] = value;\n        } else {\n          result[helpers.fieldEscape(field.name, false)] = value;\n        }\n      }\n\n      return result;\n    },\n  };\n}\n\nmodule.exports = getTextParser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}